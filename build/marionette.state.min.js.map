{"version":3,"sources":["marionette.state.min.js","/source/marionette.state.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","global","factory","exports","module","require","define","amd","Marionette","State","_","Backbone","Mn","this","syncBinding","entity","event","handlers","modelEventMatch","changeOpts","syncing","collectionMatch","Collection","match","collectionEventMatcher","modelMatch","Model","_state","modelEventMatcher","changeAttr","changeArgs","push","get","isFunction","apply","handlerKeys","split","spaceMatcher","handlerKey","sync","bindings","Error","eventStr","events","syncEntityEvents","Syncing","_when","_now","hasAnyChanged","model","_model","_len2","arguments","attrs","Array","_key2","chain","changed","keys","intersection","size","value","extend","modelClass","undefined","defaultState","componentEvents","_component","_initialState","constructor","_this","_ref","initialState","component","preventDestroy","attributes","set","_initState","bindComponent","on","state","__super__","_proxyModelEvents","getModel","getInitialState","clone","attr","val","options","reset","resetAttrs","changedAttributes","previous","previousAttributes","_len","_key","concat","toJSON","_ref2","bindEvents","listenTo","destroy","unbindComponent","unbindEvents","stopListening","entityEvents","other","trigger","state_functions","off","handler","bind","stop","index"],"mappings":"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","file":"marionette.state.min.js","sourcesContent":["/*\n * marionette.state - One-way state architecture for a Marionette.js app.\n * v1.0.1\n */\n/*\n * marionette.state - One-way state architecture for a Marionette.js app.\n * v1.0.1\n */\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('underscore'), require('backbone'), require('backbone.marionette')) : typeof define === 'function' && define.amd ? define(['underscore', 'backbone', 'backbone.marionette'], factory) : global.Marionette.State = factory(global._, global.Backbone, global.Mn);\n})(this, function (_, Backbone, Mn) {\n  'use strict';\n\n  var State = Mn.Object.extend({\n\n    // State model class to instantiate\n    modelClass: undefined,\n\n    // Default state attributes hash\n    defaultState: undefined,\n\n    // Events from my component\n    componentEvents: undefined,\n\n    // State model instance\n    _model: undefined,\n\n    // My component, facilitating lifecycle management and event bindings\n    _component: undefined,\n\n    // Initial state attributes hash after 'initialState' option and defaults are applied\n    _initialState: undefined,\n    _: undefined,\n\n    // options {\n    //   initialState: {object} Attributes that will override `defaultState`.  The result of\n    //     defaultState + initialState is the state reverted to by `#reset`.\n    //   component: {Mn object} Object to which to bind `componentEvents` and also lifecycle;\n    //     i.e., when `component` fires 'destroy', then destroy myself.\n    //   preventDestroy: {boolean} If true, then this will not destroy on `component` destroy.\n    // }\n    constructor: function constructor() {\n      var _this = this;\n\n      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var initialState = _ref.initialState;\n      var component = _ref.component;\n      var preventDestroy = _ref.preventDestroy;\n\n      Object.defineProperty(this, 'attributes', {\n        get: function get() {\n          return this._model.attributes;\n        },\n        set: function set(attributes) {\n          this._model.attributes = attributes;\n        }\n      });\n\n      // State model class is either a class option or is a standard Backbone model\n      this.modelClass = this.modelClass || Backbone.Model;\n\n      // Initialize state\n      this._initState(initialState);\n\n      if (component) {\n        this.bindComponent(component, { preventDestroy: preventDestroy });\n      }\n\n      this._model.on('change', function (state) {\n        _this._ = state;\n      });\n      State.__super__.constructor.apply(this, arguments);\n    },\n\n    // Initialize model with attrs or reset it, destructively, to conform to attrs.\n    _initState: function _initState(attrs) {\n      // Set initial state.\n      this._initialState = _.extend({}, this.defaultState, attrs);\n\n      // Create new model with initial state.\n      /* eslint-disable new-cap */\n      this._model = new this.modelClass(this._initialState);\n      this._proxyModelEvents(this._model);\n    },\n\n    // Return the state model.\n    getModel: function getModel() {\n      return this._model;\n    },\n\n    // Returns the initiate state, which is reverted to by reset()\n    getInitialState: function getInitialState() {\n      return _.clone(this._initialState);\n    },\n\n    // Proxy to model get().\n    get: function get(attr) {\n      return this._model.get(attr);\n    },\n\n    // Proxy to model set().\n    set: function set(key, val, options) {\n      this._model.set(key, val, options);\n      return this;\n    },\n\n    // Return state to its initial value.\n    // If `attrs` is provided, they will override initial values for a \"partial\" reset.\n    // Initial state will remain unchanged regardless of override attributes.\n    reset: function reset(attrs, options) {\n      var resetAttrs = _.extend({}, this._initialState, attrs);\n      this._model.set(resetAttrs, options);\n      return this;\n    },\n\n    // Proxy to model changedAttributes().\n    changedAttributes: function changedAttributes() {\n      return this._model.changedAttributes();\n    },\n\n    // Proxy to model previous().\n    previous: function previous(attr) {\n      return this._model.previous(attr);\n    },\n\n    // Proxy to model previousAttributes().\n    previousAttributes: function previousAttributes() {\n      return this._model.previousAttributes();\n    },\n\n    // Whether any of the passed attributes were changed during the last modification\n    hasAnyChanged: function hasAnyChanged() {\n      for (var _len = arguments.length, attrs = Array(_len), _key = 0; _key < _len; _key++) {\n        attrs[_key] = arguments[_key];\n      }\n\n      return State.hasAnyChanged.apply(State, [this].concat(attrs));\n    },\n\n    toJSON: function toJSON() {\n      return this._model.toJSON();\n    },\n\n    // Bind `componentEvents` to `component` and cascade destroy to self when component fires\n    // 'destroy'.  To prevent self-destroy behavior, pass `preventDestroy: true` as an option.\n    bindComponent: function bindComponent(component) {\n      var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var preventDestroy = _ref2.preventDestroy;\n\n      this.bindEvents(component, this.componentEvents);\n      if (!preventDestroy) {\n        this.listenTo(component, 'destroy', this.destroy);\n      }\n    },\n\n    // Unbind `componentEvents` from `component` and stop listening to component 'destroy' event.\n    unbindComponent: function unbindComponent(component) {\n      this.unbindEvents(component, this.componentEvents);\n      this.stopListening(component, 'destroy', this.destroy);\n    },\n\n    // Proxy to StateFunctions#syncEntityEvents.\n    syncEntityEvents: function syncEntityEvents(entity, entityEvents, event) {\n      State.syncEntityEvents(this, entity, entityEvents, event);\n      return this;\n    },\n\n    // Convert model events to state events\n    _proxyModelEvents: function _proxyModelEvents(other) {\n      this.listenTo(other, 'all', function () {\n        if (arguments.length > 1 && arguments[1] === this._model) {\n          // Replace model argument with State\n          arguments[1] = this;\n        }\n        this.trigger.apply(this, arguments);\n      });\n    }\n  });\n\n  var _state = State;\n\n  var state_functions = Object.defineProperties({}, {\n    sync: {\n      get: function get() {\n        return sync;\n      },\n      configurable: true,\n      enumerable: true\n    },\n    syncEntityEvents: {\n      get: function get() {\n        return syncEntityEvents;\n      },\n      configurable: true,\n      enumerable: true\n    },\n    hasAnyChanged: {\n      get: function get() {\n        return hasAnyChanged;\n      },\n      configurable: true,\n      enumerable: true\n    }\n  });\n\n  var modelEventMatcher = /^(?:all|change|change:(.+))$/;\n  var collectionEventMatcher = /^(?:all|reset)$/;\n  var spaceMatcher = /\\s+/;\n\n  // Sync individual event binding 'event1' => 'handler1 handler2'.\n  function syncBinding(target, entity, event, handlers) {\n    var changeOpts = { syncing: true };\n    var modelEventMatch;\n\n    // Only certain model/collection events are syncable.\n    var collectionMatch = entity instanceof Backbone.Collection && event.match(collectionEventMatcher);\n    var modelMatch = (entity instanceof Backbone.Model || entity instanceof _state) && (modelEventMatch = event.match(modelEventMatcher));\n    if (!collectionMatch && !modelMatch) {\n      return;\n    }\n\n    // Collect change event arguments.\n    var changeArgs = [entity];\n    var changeAttr;\n    if (modelEventMatch && (changeAttr = modelEventMatch[1])) {\n      changeArgs.push(entity.get(changeAttr));\n    }\n    changeArgs.push(changeOpts);\n\n    // Call change event handler.\n    if (_.isFunction(handlers)) {\n      handlers.apply(target, changeArgs);\n    } else {\n      var handlerKeys = handlers.split(spaceMatcher);\n      for (var i = 0; i < handlerKeys.length; i++) {\n        var handlerKey = handlerKeys[i];\n        target[handlerKey].apply(target, changeArgs);\n      }\n    }\n  }\n\n  // Sync bindings hash { 'event1 event 2': 'handler1 handler2' }.\n  function sync(target, entity, bindings) {\n    if (!entity) {\n      throw new Error('`entity` must be provided.');\n    }\n    if (!bindings) {\n      throw new Error('`bindings` must be provided.');\n    }\n    for (var eventStr in bindings) {\n      var handlers = bindings[eventStr];\n      var events = eventStr.split(spaceMatcher);\n      for (var i = 0; i < events.length; i++) {\n        var event = events[i];\n        syncBinding(target, entity, event, handlers);\n      }\n    }\n  }\n\n  // A stoppable handle on the syncing listener\n\n  var Syncing = (function () {\n    function Syncing(target, entity, bindings) {\n      _classCallCheck(this, Syncing);\n\n      this.target = target;\n      this.entity = entity;\n      this.bindings = bindings;\n    }\n\n    // Binds events handlers located on target to an entity using Marionette.bindEvents, and\n    // also \"syncs\" initial state either immediately or whenever target fires a specific event.\n    //\n    // Initial state is synced by calling certain handlers at a precise moment.  Only the following\n    // entity events will sync their handlers: 'all', 'change', 'change:attr', and 'reset'.\n    //\n    // Returns a Syncing instance.  While syncing handlers are unbound on target destroy, the syncing\n    // instance has a single public method stop() for ceasing syncing on target events early.\n\n    _createClass(Syncing, [{\n      key: 'stop',\n      value: function stop() {\n        Mn.unbindEvents(this.target, this.entity, this.bindings);\n        this.target.off(this.event, this.handler);\n        this.event = this.handler = null;\n      }\n    }, {\n      key: '_when',\n      value: function _when(event) {\n        Mn.bindEvents(this.target, this.entity, this.bindings);\n        this.event = event;\n        this.handler = _.bind(sync, this, this.target, this.entity, this.bindings);\n        this.target.on(this.event, this.handler).on('destroy', _.bind(this.stop, this));\n      }\n    }, {\n      key: '_now',\n      value: function _now() {\n        Mn.bindEvents(this.target, this.entity, this.bindings);\n        sync(this.target, this.entity, this.bindings);\n      }\n    }]);\n\n    return Syncing;\n  })();\n\n  function syncEntityEvents(target, entity, bindings, event) {\n    var syncing = new Syncing(target, entity, bindings);\n    if (event) {\n      syncing._when(event);\n    } else {\n      syncing._now();\n    }\n    return syncing;\n  }\n\n  // Determine if any of the passed attributes were changed during the last modification of `model`.\n  function hasAnyChanged(model) {\n    // Support Marionette.State or Backbone.Model performantly.\n    if (model._model) {\n      model = model._model;\n    }\n\n    for (var _len2 = arguments.length, attrs = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      attrs[_key2 - 1] = arguments[_key2];\n    }\n\n    return !!_.chain(model.changed).keys().intersection(attrs).size().value();\n  }\n\n  _.extend(_state, state_functions);\n\n  var index = _state;\n\n  return index;\n});\n//# sourceMappingURL=./marionette.state.js.map","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('underscore'), require('backbone'), require('backbone.marionette')) :\n  typeof define === 'function' && define.amd ? define(['underscore', 'backbone', 'backbone.marionette'], factory) :\n  global.Marionette.State = factory(global._, global.Backbone, global.Mn)\n}(this, function (_, Backbone, Mn) { 'use strict';\n\n  const State = Mn.Object.extend({\n\n    // State model class to instantiate\n    modelClass: undefined,\n\n    // Default state attributes hash\n    defaultState: undefined,\n\n    // Events from my component\n    componentEvents: undefined,\n\n    // State model instance\n    _model: undefined,\n\n    // My component, facilitating lifecycle management and event bindings\n    _component: undefined,\n\n    // Initial state attributes hash after 'initialState' option and defaults are applied\n    _initialState: undefined,\n    _: undefined,\n\n    // options {\n    //   initialState: {object} Attributes that will override `defaultState`.  The result of\n    //     defaultState + initialState is the state reverted to by `#reset`.\n    //   component: {Mn object} Object to which to bind `componentEvents` and also lifecycle;\n    //     i.e., when `component` fires 'destroy', then destroy myself.\n    //   preventDestroy: {boolean} If true, then this will not destroy on `component` destroy.\n    // }\n    constructor({ initialState, component, preventDestroy }={}) {\n      Object.defineProperty(this, 'attributes', {\n        get: function () {\n          return this._model.attributes;\n        },\n        set: function (attributes) {\n          this._model.attributes = attributes;\n        }\n      });\n\n      // State model class is either a class option or is a standard Backbone model\n      this.modelClass = this.modelClass || Backbone.Model;\n\n      // Initialize state\n      this._initState(initialState);\n\n      if (component) {\n        this.bindComponent(component, { preventDestroy });\n      }\n\n      this._model.on('change',state => { this._ = state })\n      State.__super__.constructor.apply(this, arguments);\n    },\n\n    // Initialize model with attrs or reset it, destructively, to conform to attrs.\n    _initState(attrs) {\n      // Set initial state.\n      this._initialState = _.extend({}, this.defaultState, attrs);\n\n      // Create new model with initial state.\n      /* eslint-disable new-cap */\n      this._model = new this.modelClass(this._initialState);\n      this._proxyModelEvents(this._model);\n    },\n\n    // Return the state model.\n    getModel() {\n      return this._model;\n    },\n\n    // Returns the initiate state, which is reverted to by reset()\n    getInitialState() {\n      return _.clone(this._initialState);\n    },\n\n    // Proxy to model get().\n    get(attr) {\n      return this._model.get(attr);\n    },\n\n    // Proxy to model set().\n    set(key, val, options) {\n      this._model.set(key, val, options);\n      return this;\n    },\n\n    // Return state to its initial value.\n    // If `attrs` is provided, they will override initial values for a \"partial\" reset.\n    // Initial state will remain unchanged regardless of override attributes.\n    reset(attrs, options) {\n      var resetAttrs = _.extend({}, this._initialState, attrs);\n      this._model.set(resetAttrs, options);\n      return this;\n    },\n\n    // Proxy to model changedAttributes().\n    changedAttributes() {\n      return this._model.changedAttributes();\n    },\n\n    // Proxy to model previous().\n    previous(attr) {\n      return this._model.previous(attr);\n    },\n\n    // Proxy to model previousAttributes().\n    previousAttributes() {\n      return this._model.previousAttributes();\n    },\n\n    // Whether any of the passed attributes were changed during the last modification\n    hasAnyChanged(...attrs) {\n      return State.hasAnyChanged(this, ...attrs);\n    },\n\n    toJSON() {\n      return this._model.toJSON();\n    },\n\n    // Bind `componentEvents` to `component` and cascade destroy to self when component fires\n    // 'destroy'.  To prevent self-destroy behavior, pass `preventDestroy: true` as an option.\n    bindComponent(component, { preventDestroy }={}) {\n      this.bindEvents(component, this.componentEvents);\n      if (!preventDestroy) {\n        this.listenTo(component, 'destroy', this.destroy);\n      }\n    },\n\n    // Unbind `componentEvents` from `component` and stop listening to component 'destroy' event.\n    unbindComponent(component) {\n      this.unbindEvents(component, this.componentEvents);\n      this.stopListening(component, 'destroy', this.destroy);\n    },\n\n    // Proxy to StateFunctions#syncEntityEvents.\n    syncEntityEvents(entity, entityEvents, event) {\n      State.syncEntityEvents(this, entity, entityEvents, event);\n      return this;\n    },\n\n    // Convert model events to state events\n    _proxyModelEvents(other) {\n      this.listenTo(other, 'all', function () {\n        if (arguments.length > 1 && arguments[1] === this._model) {\n          // Replace model argument with State\n          arguments[1] = this;\n        }\n        this.trigger.apply(this, arguments);\n      });\n    }\n  });\n\n  var _state = State;\n\n  var state_functions = {\n    get sync () { return sync; },\n    get syncEntityEvents () { return syncEntityEvents; },\n    get hasAnyChanged () { return hasAnyChanged; }\n  };\n\n  const modelEventMatcher = /^(?:all|change|change:(.+))$/;\n  const collectionEventMatcher = /^(?:all|reset)$/;\n  const spaceMatcher = /\\s+/;\n\n  // Sync individual event binding 'event1' => 'handler1 handler2'.\n  function syncBinding(target, entity, event, handlers) {\n    var changeOpts = { syncing: true };\n    var modelEventMatch;\n\n    // Only certain model/collection events are syncable.\n    var collectionMatch =\n        entity instanceof Backbone.Collection &&\n        event.match(collectionEventMatcher);\n    var modelMatch =\n        (entity instanceof Backbone.Model || entity instanceof _state) &&\n        (modelEventMatch = event.match(modelEventMatcher));\n    if (!collectionMatch && !modelMatch) { return; }\n\n    // Collect change event arguments.\n    var changeArgs = [entity];\n    var changeAttr;\n    if (modelEventMatch && (changeAttr = modelEventMatch[1])) {\n      changeArgs.push(entity.get(changeAttr));\n    }\n    changeArgs.push(changeOpts);\n\n    // Call change event handler.\n    if (_.isFunction(handlers)) {\n      handlers.apply(target, changeArgs);\n    } else {\n      var handlerKeys = handlers.split(spaceMatcher);\n      for (var i = 0; i < handlerKeys.length; i++) {\n        var handlerKey = handlerKeys[i];\n        target[handlerKey].apply(target, changeArgs);\n      }\n    }\n  }\n\n  // Sync bindings hash { 'event1 event 2': 'handler1 handler2' }.\n  function sync(target, entity, bindings) {\n    if (!entity) { throw new Error('`entity` must be provided.'); }\n    if (!bindings) { throw new Error('`bindings` must be provided.'); }\n    for (var eventStr in bindings) {\n      var handlers = bindings[eventStr];\n      var events = eventStr.split(spaceMatcher);\n      for (var i = 0; i < events.length; i++) {\n        var event = events[i];\n        syncBinding(target, entity, event, handlers);\n      }\n    }\n  }\n\n  // A stoppable handle on the syncing listener\n  class Syncing {\n\n    constructor(target, entity, bindings) {\n      this.target = target;\n      this.entity = entity;\n      this.bindings = bindings;\n    }\n\n    stop() {\n      Mn.unbindEvents(this.target, this.entity, this.bindings);\n      this.target.off(this.event, this.handler);\n      this.event = this.handler = null;\n    }\n\n    _when(event) {\n      Mn.bindEvents(this.target, this.entity, this.bindings);\n      this.event = event;\n      this.handler = _.bind(sync, this, this.target, this.entity, this.bindings);\n      this.target\n        .on(this.event, this.handler)\n        .on('destroy', _.bind(this.stop, this));\n    }\n\n    _now() {\n      Mn.bindEvents(this.target, this.entity, this.bindings);\n      sync(this.target, this.entity, this.bindings);\n    }\n  }\n\n  // Binds events handlers located on target to an entity using Marionette.bindEvents, and\n  // also \"syncs\" initial state either immediately or whenever target fires a specific event.\n  //\n  // Initial state is synced by calling certain handlers at a precise moment.  Only the following\n  // entity events will sync their handlers: 'all', 'change', 'change:attr', and 'reset'.\n  //\n  // Returns a Syncing instance.  While syncing handlers are unbound on target destroy, the syncing\n  // instance has a single public method stop() for ceasing syncing on target events early.\n  function syncEntityEvents(target, entity, bindings, event) {\n    var syncing = new Syncing(target, entity, bindings);\n    if (event) {\n      syncing._when(event);\n    } else {\n      syncing._now();\n    }\n    return syncing;\n  }\n\n  // Determine if any of the passed attributes were changed during the last modification of `model`.\n  function hasAnyChanged(model, ...attrs) {\n    // Support Marionette.State or Backbone.Model performantly.\n    if (model._model) { model = model._model; }\n    return !!_.chain(model.changed)\n      .keys()\n      .intersection(attrs)\n      .size()\n      .value();\n  }\n\n  _.extend(_state, state_functions);\n\n  var index = _state;\n\n  return index;\n\n}));\n//# sourceMappingURL=./marionette.state.js.map"],"sourceRoot":"/source/"}